locs$lbmp <- lbmp$LBMP
##locs = na.omit(locs)
##locs <- locs[!is.na(locs$lbmp),]
library("treemap")
library("viridisLite")
tm <- treemap(locs, index = c("zone", "id"),
vSize = "lbmp", sortID = "lat", vColor = "lbmp",
type = "value", algorithm = "squarified", palette = viridis(6))
hc_tm <- highchart(height = 800) %>%
hc_add_series_treemap(tm, allowDrillToNode = TRUE,  vSize = "lbmp^10", sortID = "lat", vColor = "lbmp", dataLabels = F, layoutAlgorithm = "squarified",name = "tmdata")
hc_tm
library("treemap")
library("viridisLite")
library(dismo)
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("x", "id", "lon", "lat", "zone", "dir"), header = T, na.strings = c("null", 0))
lbmp = read.csv("Test Data2.csv", skip = 2, fill = T, col.names = c("ID", "time", "LBMP", "loss", "congestion"), header = T, na.strings = c("null", 0))
locs <- locs[-c(1)]
lbmp <- lbmp[-c(1,2,4,5)]
locs$lbmp <- lbmp$LBMP
##locs = na.omit(locs)
##locs <- locs[!is.na(locs$lbmp),]
library("treemap")
library("viridisLite")
tm <- treemap(locs, index = c("zone", "id"),
vSize = "lbmp", sortID = "lat", vColor = "lbmp",
type = "value", algorithm = "squarified", palette = viridis(6))
hc_tm <- highchart(height = 800) %>%
hc_add_series_treemap(tm, allowDrillToNode = TRUE,  vSize = "lbmp", sortID = "lat", vColor = "lbmp^5", dataLabels = F, layoutAlgorithm = "squarified",name = "tmdata")
hc_tm
library("treemap")
library("viridisLite")
library(dismo)
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("x", "id", "lon", "lat", "zone", "dir"), header = T, na.strings = c("null", 0))
lbmp = read.csv("Test Data2.csv", skip = 2, fill = T, col.names = c("ID", "time", "LBMP", "loss", "congestion"), header = T, na.strings = c("null", 0))
locs <- locs[-c(1)]
lbmp <- lbmp[-c(1,2,4,5)]
locs$lbmp <- lbmp$LBMP
##locs = na.omit(locs)
##locs <- locs[!is.na(locs$lbmp),]
library("treemap")
library("viridisLite")
tm <- treemap(locs, index = c("zone", "id"),
vSize = "lbmp", sortID = "lat", vColor = "lbmp",
type = "value", algorithm = "squarified", palette = viridis(6))
hc_tm <- highchart(height = 800) %>%
hc_add_series_treemap(tm, allowDrillToNode = TRUE,  vSize = "lbmp", sortID = "lat", vColor = "lbmp^5", dataLabels = F, name = "tmdata")
hc_tm
library("treemap")
library("viridisLite")
library(dismo)
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("x", "id", "lon", "lat", "zone", "dir"), header = T, na.strings = c("null", 0))
lbmp = read.csv("Test Data2.csv", skip = 2, fill = T, col.names = c("ID", "time", "LBMP", "loss", "congestion"), header = T, na.strings = c("null", 0))
locs <- locs[-c(1)]
lbmp <- lbmp[-c(1,2,4,5)]
locs$lbmp <- lbmp$LBMP
##locs = na.omit(locs)
##locs <- locs[!is.na(locs$lbmp),]
library("treemap")
library("viridisLite")
tm <- treemap(locs, index = c("zone", "id"),
vSize = "lbmp", sortID = "lat", vColor = "lbmp",
type = "value", algorithm = "squarified", palette = viridis(6))
hc_tm <- highchart(height = 800) %>%
hc_add_series_treemap(tm, allowDrillToNode = TRUE,  vSize = "lbmp", sortID = "lat", vColor = "lbmp^5", dataLabels = F, layoutAlgorithm = "squarified",name = "tmdata")
hc_tm
library("treemap")
library("viridisLite")
library(dismo)
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("x", "id", "lon", "lat", "zone", "dir"), header = T, na.strings = c("null", 0))
lbmp = read.csv("Test Data2.csv", skip = 2, fill = T, col.names = c("ID", "time", "LBMP", "loss", "congestion"), header = T, na.strings = c("null", 0))
locs <- locs[-c(1)]
lbmp <- lbmp[-c(1,2,4,5)]
locs$lbmp <- lbmp$LBMP
##locs = na.omit(locs)
##locs <- locs[!is.na(locs$lbmp),]
library("treemap")
library("viridisLite")
tm <- treemap(locs, index = c("zone", "id"),
vSize = "lbmp", sortID = "lat", vColor = "-lbmp",
type = "value", algorithm = "squarified", palette = viridis(6))
hc_tm <- highchart(height = 800) %>%
hc_add_series_treemap(tm, allowDrillToNode = TRUE,  vSize = "lbmp", sortID = "lat", vColor = "lbmp^5", dataLabels = F, layoutAlgorithm = "squarified",name = "tmdata")
hc_tm
library("treemap")
library("viridisLite")
library(dismo)
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("x", "id", "lon", "lat", "zone", "dir"), header = T, na.strings = c("null", 0))
lbmp = read.csv("Test Data2.csv", skip = 2, fill = T, col.names = c("ID", "time", "LBMP", "loss", "congestion"), header = T, na.strings = c("null", 0))
locs <- locs[-c(1)]
lbmp <- lbmp[-c(1,2,4,5)]
locs$lbmp <- lbmp$LBMP
##locs = na.omit(locs)
##locs <- locs[!is.na(locs$lbmp),]
library("treemap")
library("viridisLite")
tm <- treemap(locs, index = c("zone", "id"),
vSize = "lbmp", sortID = "lat", vColor = "lbmp",
type = "value", algorithm = "squarified", palette = viridis(6))
hc_tm <- highchart(height = 800) %>%
hc_add_series_treemap(tm, allowDrillToNode = TRUE,  vSize = "lbmp", sortID = "lat", vColor = "-lbmp", dataLabels = F, layoutAlgorithm = "squarified",name = "tmdata")
hc_tm
library(dismo)
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "name", "lon", "lat"), header = T, na.strings = c("null", 0))
lbmp = read.csv("Test Data2.csv", skip = 1, fill = T, col.names = c("ID", "time", "LBMP", "loss", "congestion"), header = T, na.strings = c("null", 0))
locs <- locs[-c(1)]
lbmp <- lbmp[-c(1,2,4,5)]
locs$lbmp <- lbmp$LBMP
locs = na.omit(locs)
locs <- locs[!is.na(locs$lbmp),]
library(plotly)
# change default color scale title
m <- list(colorbar = list(title = "LBMP", tickprefix = '$'))
# geo styling
g <- list(
scope = 'usa',
showland = TRUE,
landcolor = toRGB("grey83"),
subunitcolor = toRGB("white"),
countrycolor = toRGB("white"),
showlakes = TRUE,
lakecolor = toRGB("white"),
showsubunits = TRUE,
showcountries = TRUE,
resolution = 20,
projection = list(
type = 'conic conformal',
rotation = list(
lon = -100
)
),
lonaxis = list(
showgrid = TRUE,
gridwidth = 0.5,
range = c(-80, -70),
dtick = 0.5
),
lataxis = list(
showgrid = TRUE,
gridwidth = 0.5,
range = c(40, 46),
dtick = 0.5
)
)
plot_ly(locs, size = locs$lbmp, lat = locs$lat, lon = locs$lon, text = paste("LBMP: $", locs$lbmp), color = locs$lbmp,
type = 'scattergeo', marker = m)
layout(title = '', geo = g)
## plotly_POST(p, filename = "NYISO_Pricing", world_readable = TRUE)
require(akima)
require(rgl)
require(plot3D)
require(fields)
s=interp(x,y,z, duplicate = "mean")
mesh(s$x,s$y,s$z)
s=interp(x,y,z, duplicate = "mean")
mesh(s$x,s$y,s$z)
surf3D (x, y, z, theta = 90)
scatter3D(x, y, z, theta= 0, phi = 90, pch = "", cex = 3, colkey = FALSE)
image2D(s$x,s$y,s$z)
library(plot3D)
image2D(z,x,y)
library(zoo)
Volcano <- volcano[seq(1, nrow(volcano), by = 1), seq(1, ncol(volcano), by = 1)]
image2D(s, axes = F, resfac = 10, alpha = 1, rasterImage = TRUE, colkey = F, contour = F)
test = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "Name", "Longitude", "Latitude"), header = T, na.strings = c("null", 0))
test2 = read.csv("Test Data2.csv", skip = 1, fill = T, col.names = c("ID", "Time", "LBMP", "Loss", "Congestion"), header = T, na.strings = c("null", 0))
test <- test[-c(1,2)]
test <- test[-c(4,6,7)]
test2 <- test2[-c(1,2,4,5)]
test$LBMP <- test2
test= na.omit(test)
test <- test[!is.na(test$LBMP),]
x = as.vector(test$Longitude)
y = as.vector(test$Latitude)
z = as.vector(as.vector(test$LBMP)$LBMP)
##kriged <- kriging(x, y, z, polygons=p, pixels=500)
resolution <- 0.01 # you can increase the resolution by decreasing this number (warning: the resulting dataframe size increase very quickly)
a <- interp(x=x, y=y, z=z,
xo=seq(-80, -72, by=resolution),
yo=seq(40, 47,by=resolution), duplicate="mean")
filled.contour(a, axes = F, color.palette=heat.colors, nlevels = 500)
a <- interp(x=x, y=y, z=z,duplicate="mean")
filled.contour(a, axes = F, color.palette=heat.colors, nlevels = 500)
a <- interp(x=x, y=y, z=z,
xo=seq(-80, -72, by=resolution),
yo=seq(40, 47,by=resolution), duplicate="mean")
filled.contour(a, axes = F, color.palette=heat.colors, nlevels = 500)
test = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "Name", "Longitude", "Latitude"), header = T, na.strings = c("null", 0))
test2 = read.csv("Test Data2.csv", skip = 1, fill = T, col.names = c("ID", "Time", "LBMP", "Loss", "Congestion"), header = T, na.strings = c("null", 0))
test <- test[-c(1,2)]
test <- test[-c(4,6,7)]
test2 <- test2[-c(1,2,4,5)]
test$LBMP <- test2
test= na.omit(test)
test <- test[!is.na(test$LBMP),]
x = as.vector(test$Longitude)
y = as.vector(test$Latitude)
z = as.vector(as.vector(test$LBMP)$LBMP)
##kriged <- kriging(x, y, z, polygons=p, pixels=500)
resolution <- 0.01 # you can increase the resolution by decreasing this number (warning: the resulting dataframe size increase very quickly)
a <- interp(x=x, y=y, z=z,
xo=seq(0.25, length = 500),
yo=seq(0.25, length = 500), duplicate="mean")
filled.contour(a, axes = F, color.palette=heat.colors, nlevels = 500)
require(akima)
require(rgl)
require(plot3D)
require(fields)
s=interp(x,y,z, duplicate = "mean")
mesh(s$x,s$y,s$z)
surf3D (x, y, z, theta = 90)
scatter3D(x, y, z, theta= 0, phi = 90, pch = "", cex = 3, colkey = FALSE)
image2D(s$x,s$y,s$z)
library(plot3D)
image2D(z,x,y)
library(zoo)
Volcano <- volcano[seq(1, nrow(volcano), by = 1), seq(1, ncol(volcano), by = 1)]
image2D(s, axes = F, resfac = 10, alpha = 1, rasterImage = TRUE, colkey = F, contour = F)
test = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "Name", "Longitude", "Latitude"), header = T, na.strings = c("null", 0))
test2 = read.csv("Test Data2.csv", skip = 1, fill = T, col.names = c("ID", "Time", "LBMP", "Loss", "Congestion"), header = T, na.strings = c("null", 0))
test <- test[-c(1,2)]
test <- test[-c(4,6,7)]
test2 <- test2[-c(1,2,4,5)]
test$LBMP <- test2
test= na.omit(test)
test <- test[!is.na(test$LBMP),]
x = as.vector(test$Longitude)
y = as.vector(test$Latitude)
z = as.vector(as.vector(test$LBMP)$LBMP)
##kriged <- kriging(x, y, z, polygons=p, pixels=500)
resolution <- 0.01 # you can increase the resolution by decreasing this number (warning: the resulting dataframe size increase very quickly)
a <- interp(x=x, y=y, z=z,
xo=seq(0.25, length = 100),
yo=seq(0.25, length = 100), duplicate="mean")
filled.contour(a, axes = F, color.palette=heat.colors, nlevels = 500)
#####################
# Krige random data for a specified area using a list of polygons
library(maps)
usa <- map("usa", "main", plot = FALSE)
p <- list(data.frame(usa$x, usa$y))
# Create some random data
x <- runif(50, min(p[[1]][,1]), max(p[[1]][,1]))
y <- runif(50, min(p[[1]][,2]), max(p[[1]][,2]))
z <- rnorm(50)
# Krige and create the map
kriged <- kriging(x, y, z, polygons=p, pixels=300)
image(kriged, xlim = extendrange(x), ylim = extendrange(y))
filled.contour(volcano, color = terrain.colors, asp = 1) # simple
x <- 10*1:nrow(volcano)
f <- volcano
y <- 10*1:ncol(volcano)
filled.contour(x, y, volcano, color = terrain.colors,
plot.title = title(main = "The Topography of Maunga Whau",
xlab = "Meters North", ylab = "Meters West"),
plot.axes = { axis(1, seq(100, 800, by = 100))
axis(2, seq(100, 600, by = 100)) },
key.title = title(main = "Height\n(meters)"),
key.axes = axis(4, seq(90, 190, by = 10)))  # maybe also asp = 1
mtext(paste("filled.contour(.) from", R.version.string),
side = 1, line = 4, adj = 1, cex = .66)
xy <- data.frame(test$Longitude, test$Latitude)
library(akima)
vals <- as.vector(test$LBMP)
vals <- as.vector(vals$LBMP)
spline <- Tps(xy, vals)
intras <- interp(x,y, vals, duplicate = "mean")
plot(intras)
locs2ras <- rasterize(xy, field = rep(1, nrow(xy)))
locs2ras
plot(locs2ras)
test = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "Name", "Longitude", "Latitude"), header = T, na.strings = c("null", 0))
test2 = read.csv("Test Data2.csv", skip = 1, fill = T, col.names = c("ID", "Time", "LBMP", "Loss", "Congestion"), header = T, na.strings = c("null", 0))
test <- test[-c(1,2)]
test <- test[-c(4,6,7)]
test2 <- test2[-c(1,2,4,5)]
test$LBMP <- test2
test= na.omit(test)
test <- test[!is.na(test$LBMP),]
x = as.vector(test$Longitude)
y = as.vector(test$Latitude)
z = as.vector(as.vector(test$LBMP)$LBMP)
##kriged <- kriging(x, y, z, polygons=p, pixels=500)
resolution <- 0.01 # you can increase the resolution by decreasing this number (warning: the resulting dataframe size increase very quickly)
a <- interp(x=x, y=y, z=z,
xo=seq(0.25, length = 100),
yo=seq(0.25, length = 100), duplicate="mean")
filled.contour(a, axes = F, color.palette=heat.colors, nlevels = 500)
test = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "Name", "Longitude", "Latitude", "x"), header = T, na.strings = c("null", 0))
test2 = read.csv("Test Data2.csv", skip = 1, fill = T, col.names = c("ID", "Time", "LBMP", "Loss", "Congestion"), header = T, na.strings = c("null", 0))
test <- test[-c(1,2)]
test <- test[-c(4,6,7)]
test2 <- test2[-c(1,2,4,5)]
test$LBMP <- test2
test= na.omit(test)
test <- test[!is.na(test$LBMP),]
x = as.vector(test$Longitude)
y = as.vector(test$Latitude)
z = as.vector(as.vector(test$LBMP)$LBMP)
##kriged <- kriging(x, y, z, polygons=p, pixels=500)
resolution <- 0.01 # you can increase the resolution by decreasing this number (warning: the resulting dataframe size increase very quickly)
a <- interp(x=x, y=y, z=z,
xo=seq(0.25, length = 100),
yo=seq(0.25, length = 100), duplicate="mean")
filled.contour(a, axes = F, color.palette=heat.colors, nlevels = 500)
a <- interp(x=x, y=y, z=z, duplicate="mean")
filled.contour(a, axes = F, color.palette=heat.colors, nlevels = 500)
resolution <- 0.01 # you can increase the resolution by decreasing this number (warning: the resulting dataframe size increase very quickly)
a <- interp(x=x, y=y, z=z,
xo=seq(0.25, length = 100),
yo=seq(0.25, length = 100), duplicate="mean")
x = as.vector(test$Longitude)
y = as.vector(test$Latitude)
z = as.vector(as.vector(test$LBMP)$LBMP)
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "name", "lon", "lat"), header = T, na.strings = c("null", 0))
lbmp = read.csv("Test Data2.csv", skip = 1, fill = T, col.names = c("ID", "time", "LBMP", "loss", "congestion"), header = T, na.strings = c("null", 0))
locs <- locs[-c(1)]
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "name", "lon", "lat"), header = T, na.strings = c("null", 0))
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "name", "lon", "lat", "x"), header = T, na.strings = c("null", 0))
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "name", "lon", "lat"), header = T, na.strings = c("null", 0))
lbmp = read.csv("Test Data2.csv", skip = 1, fill = T, col.names = c("ID", "time", "LBMP", "loss", "congestion"), header = T, na.strings = c("null", 0))
locs <- locs[-c(1)]
lbmp <- lbmp[-c(1,2,4,5)]
locs$lbmp <- lbmp$LBMP
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "name", "lon", "lat"), header = T, na.strings = c("null", 0))
lbmp = read.csv("Test Data2.csv", skip = 2, fill = T, col.names = c("ID", "time", "LBMP", "loss", "congestion"), header = T, na.strings = c("null", 0))
locs <- locs[-c(1)]
lbmp <- lbmp[-c(1,2,4,5)]
locs$lbmp <- lbmp$LBMP
locs = na.omit(locs)
locs <- locs[!is.na(locs$lbmp),]
x = as.vector(locs$lon)
y = as.vector(locs$lat)
z = as.vector(as.vector(locs$lbmp)$LBMP)
x = as.vector(locs$lon)
y = as.vector(locs$lat)
z = as.vector(locs$lbmp)
resolution <- 0.01 # you can increase the resolution by decreasing this number (warning: the resulting dataframe size increase very quickly)
a <- interp(x=x, y=y, z=z,
xo=seq(0.25, length = 100),
yo=seq(0.25, length = 100), duplicate="mean")
filled.contour(a, axes = F, color.palette=heat.colors, nlevels = 500)
a <- interp(x=x, y=y, z=z, xo=seq(0.25, length = 100), yo=seq(0.25, length = 100), duplicate="mean")
filled.contour(a, axes = F, color.palette=heat.colors, nlevels = 500)
a <- interp(x=x, y=y, z=z, duplicate="mean")
filled.contour(a, axes = F, color.palette=heat.colors, nlevels = 500)
RSiteSearch("blank map contour")
# Krige random data for a specified area using a list of polygons
library(maps)
usa <- map("usa", "main", plot = FALSE)
p <- list(data.frame(usa$x, usa$y))
# Create some random data
x <- runif(50, min(p[[1]][,1]), max(p[[1]][,1]))
z <- rnorm(50)
y <- runif(50, min(p[[1]][,2]), max(p[[1]][,2]))
# Krige and create the map
kriged <- kriging(x, y, z, polygons=p, pixels=300)
image(kriged, xlim = extendrange(x), ylim = extendrange(y))
library(akima)
library(maps)
library(mapdata)
GRID.RES <- 500
## original values
x <- seq(100,170,le=10) + runif(10,-5,5)
y <- seq(-50,0,le=10) + runif(10,-5,5)
z <- x*y + rnorm(length(x),2)
## interpolation using akima
x0 <- seq(100,170,le=GRID.RES)
y0 <- seq(-50,0,le=GRID.RES)
z.hat <- interp(x,y, z, xo=x0, yo=y0, linear = FALSE, extrap=TRUE)
## find loc in australia, set others to NA
myGrid <- expand.grid(x0, y0)
temp <- map.where(x=myGrid[,1], y=myGrid[,2])
toKeep <- grep("australia",temp, ignore.case=TRUE)
toRemove <- setdiff(1:length(z.hat$z), toKeep)
z.hat$z[toRemove] <- NA
## plot
image(z.hat)
map(add=TRUE, lwd=3)
contour(z.hat,add=TRUE)
library(akima)
library(maps)
library(mapdata)
GRID.RES <- 500
## original values
x <- seq(100,170,le=10) + runif(10,-5,5)
y <- seq(-50,0,le=10) + runif(10,-5,5)
z <- x*y + rnorm(length(x),2)
## interpolation using akima
x0 <- seq(100,170,le=GRID.RES)
y0 <- seq(-50,0,le=GRID.RES)
z.hat <- interp(x,y, z, xo=x0, yo=y0, linear = FALSE, extrap=TRUE)
## find loc in australia, set others to NA
myGrid <- expand.grid(x0, y0)
temp <- map.where(x=myGrid[,1], y=myGrid[,2])
toKeep <- grep("new york",temp, ignore.case=TRUE)
toRemove <- setdiff(1:length(z.hat$z), toKeep)
z.hat$z[toRemove] <- NA
## plot
image(z.hat)
map(add=TRUE, lwd=3)
contour(z.hat,add=TRUE)
############
#####################
GRID.RES <- 500
## original values
x <- seq(100,170,le=10) + runif(10,-5,5)
y <- seq(-50,0,le=10) + runif(10,-5,5)
z <- x*y + rnorm(length(x),2)
## interpolation using akima
x0 <- seq(100,170,le=GRID.RES)
y0 <- seq(-50,0,le=GRID.RES)
z.hat <- interp(x,y, z, xo=x0, yo=y0, linear = FALSE, extrap=TRUE)
## find loc in australia, set others to NA
myGrid <- expand.grid(x0, y0)
temp <- map.where(x=myGrid[,1], y=myGrid[,2])
toKeep <- grep("usa",temp, ignore.case=TRUE)
toRemove <- setdiff(1:length(z.hat$z), toKeep)
z.hat$z[toRemove] <- NA
## plot
image(z.hat)
map(add=TRUE, lwd=3)
contour(z.hat,add=TRUE)
############
#####################
x <- seq(100,170,le=10) + runif(10,-5,5)
y <- seq(-50,0,le=10) + runif(10,-5,5)
z <- x*y + rnorm(length(x),2)
x0 <- seq(100,170,le=GRID.RES)
y0 <- seq(-50,0,le=GRID.RES)
z.hat <- interp(x,y, z, xo=x0, yo=y0, linear = FALSE, extrap=TRUE)
x <- seq(100,170,le=10) + runif(10,-5,5)
y <- seq(-50,0,le=10) + runif(10,-5,5)
z <- x*y + rnorm(length(x),2)
x0 <- seq(100,170,le=GRID.RES)
y0 <- seq(-50,0,le=GRID.RES)
GRID.RES <- 500
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "name", "lon", "lat"), header = T, na.strings = c("null", 0))
lbmp = read.csv("Test Data2.csv", skip = 2, fill = T, col.names = c("ID", "time", "LBMP", "loss", "congestion"), header = T, na.strings = c("null", 0))
locs <- locs[-c(1)]
lbmp <- lbmp[-c(1,2,4,5)]
locs$lbmp <- lbmp$LBMP
locs = na.omit(locs)
locs <- locs[!is.na(locs$lbmp),]
x = as.vector(locs$lon)
y = as.vector(locs$lat)
z = as.vector(locs$lbmp)
x0 <- seq(100,170,le=GRID.RES)
y0 <- seq(-50,0,le=GRID.RES)
z.hat <- interp(x,y, z, xo=x0, yo=y0, linear = FALSE, extrap=TRUE)
x0 <- seq(100,170,le=GRID.RES)
y0 <- seq(-50,0,le=GRID.RES)
z.hat <- interp(x,y, z, xo=x0, yo=y0, linear = FALSE, duplicate="mean", extrap=TRUE)
myGrid <- expand.grid(x0, y0)
temp <- map.where(x=myGrid[,1], y=myGrid[,2])
toKeep <- grep("australia",temp, ignore.case=TRUE)
toRemove <- setdiff(1:length(z.hat$z), toKeep)
z.hat$z[toRemove] <- NA
x0 <- seq(45,50,le=GRID.RES)
y0 <- seq(-80,-75,le=GRID.RES)
z.hat <- interp(x,y, z, xo=x0, yo=y0, linear = FALSE, duplicate="mean", extrap=TRUE)
## find loc in australia, set others to NA
myGrid <- expand.grid(x0, y0)
temp <- map.where(x=myGrid[,1], y=myGrid[,2])
toKeep <- grep("usa",temp, ignore.case=TRUE)
toRemove <- setdiff(1:length(z.hat$z), toKeep)
z.hat$z[toRemove] <- NA
## plot
image(z.hat)
map(add=TRUE, lwd=3)
contour(z.hat,add=TRUE)
x <- seq(100,170,le=10) + runif(10,-5,5)
y <- seq(-50,0,le=10) + runif(10,-5,5)
z <- x*y + rnorm(length(x),2)
x0 <- seq(45,50,le=GRID.RES)
y0 <- seq(-80,-75,le=GRID.RES)
z.hat <- interp(x,y, z, xo=x0, yo=y0, linear = FALSE, duplicate="mean", extrap=TRUE)
myGrid <- expand.grid(x0, y0)
temp <- map.where(x=myGrid[,1], y=myGrid[,2])
toKeep <- grep("usa",temp, ignore.case=TRUE)
toRemove <- setdiff(1:length(z.hat$z), toKeep)
z.hat$z[toRemove] <- NA
## plot
image(z.hat)
z.hat
x0 <- seq(45,50,le=GRID.RES)
y0 <- seq(-80,-75,le=GRID.RES)
z.hat <- interp(x,y, z, xo=x0, yo=y0, linear = FALSE, duplicate="mean", extrap=TRUE)
## find loc in australia, set others to NA
myGrid <- expand.grid(x0, y0)
temp <- map.where(x=myGrid[,1], y=myGrid[,2])
toKeep <- grep("australia",temp, ignore.case=TRUE)
toRemove <- setdiff(1:length(z.hat$z), toKeep)
z.hat$z[toRemove] <- NA
## plot
image(z.hat)
map(add=TRUE, lwd=3)
contour(z.hat,add=TRUE)
############
locs = read.csv("Test Data.csv", skip = 2, fill = T, col.names = c("ID", "name", "lon", "lat"), header = T, na.strings = c("null", 0))
lbmp = read.csv("Test Data2.csv", skip = 1, fill = T, col.names = c("ID", "time", "LBMP", "loss", "congestion"), header = T, na.strings = c("null", 0))
locs <- locs[-c(1)]
lbmp <- lbmp[-c(1,2,4,5)]
locs$lbmp <- lbmp$LBMP
locs = na.omit(locs)
locs <- locs[!is.na(locs$lbmp),]
x = as.vector(locs$lon)
y = as.vector(locs$lat)
z = as.vector(locs$lbmp)
x0 <- seq(40,46,le=GRID.RES)
y0 <- seq(-80,-70,le=GRID.RES)
z.hat <- interp(x,y, z, xo=x0, yo=y0, linear = FALSE, duplicate="mean", extrap=TRUE)
z.hat <- interp(x,y, z, xo=x0, yo=y0, linear = FALSE, duplicate="mean")
z.hat <- interp(x,y, z, xo=x0, yo=y0, linear = FALSE, duplicate="mean")
